<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Document Search & Viewer with OCR</title>
</head>
 <link rel="stylesheet" href="css/main.css">
 <script src="js/utils.js"></script>
<body>
    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <!-- Login Screen -->
    <div id="loginScreen" class="login-container">
        <div class="login-box">
            <h1>üìÑ Document Search</h1>
            <p style="margin-bottom: 2rem; color: var(--text-light);">Advanced Document Management with OCR, Full-Text Search, PDF Page Splitting, Editing, Drag-and-Drop Reordering & Add Pages to Existing Documents</p>
            
            <form id="loginForm">
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" class="form-control" required autocomplete="username" value="admin">
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" class="form-control" required autocomplete="current-password" value="admin123">
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;" id="loginBtn">
                    <span id="loginBtnText">Sign In</span>
                    <span id="loginLoader" class="loading hidden"></span>
                </button>
            </form>
            
            <div id="loginError" class="alert alert-error hidden" style="margin-top: 1rem;"></div>
            
            <div style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; font-size: 0.9rem; color: var(--text-light);">
                <strong>Demo Credentials:</strong><br>
                Username: admin<br>
                Password: admin123<br><br>
                <strong>üÜï Enhanced Features:</strong><br>
                ‚Ä¢ üîç OCR text extraction<br>
                ‚Ä¢ üìù Full-text search<br>
                ‚Ä¢ üìÑ PDF page splitting<br>
                ‚Ä¢ ‚úèÔ∏è Edit document index fields<br>
                ‚Ä¢ üóëÔ∏è Soft delete documents<br>
                ‚Ä¢ üîÑ Drag & drop page reordering<br>
                ‚Ä¢ üì§ Add pages to existing documents
            </div>
        </div>
    </div>

    <!-- Main Application -->
    <div id="mainApp" class="container hidden">
        <!-- Header -->
        <div class="header">
            <h1>üìÑ Advanced Document Search & Viewer with OCR</h1>
            <p>Find, view, edit and manage your business documents with powerful OCR text extraction, full-text search, automatic filename-based indexing, PDF page splitting, field editing, drag-and-drop page reordering, and add pages to existing documents</p>
            <div class="user-info">
                <div class="user-avatar" id="userAvatar"></div>
                <div>
                    <div id="userDisplay" style="font-weight: 600;"></div>
                    <div id="userRole" style="font-size: 0.9rem; opacity: 0.8;"></div>
                </div>
                <button class="btn btn-secondary btn-sm" onclick="logout()">
                    üö™ Logout
                </button>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <button class="btn btn-info btn-sm" onclick="showRecentDocuments()">
                üïí Recent Documents
            </button>
            <button class="btn btn-warning btn-sm" onclick="showFavoriteDocuments()">
                ‚≠ê Favorites
            </button>
            <button class="btn btn-success btn-sm" onclick="refreshProjects()">
                üîÑ Refresh Projects
            </button>
            <!-- Admin Panel Link (only shown for administrators) -->
            <div id="adminControls" class="hidden" style="margin-left: auto; display: flex; gap: 1rem;">
                <a href="/admin" class="btn btn-danger btn-sm">
                    üîß Admin Panel
                    <span class="admin-badge">Admin</span>
                </a>
                <button class="btn btn-secondary btn-sm" onclick="exportResults()">
                    üìä Export Results
                </button>
            </div>
            <div id="regularControls" style="margin-left: auto;">
                <button class="btn btn-secondary btn-sm" onclick="exportResults()">
                    üìä Export Results
                </button>
            </div>
        </div>

        <!-- Search Section -->
        <div class="search-section">
            <!-- Project Selector -->
            <div class="project-selector">
                <h2>üöÄ Select a Project</h2>
                <div class="alert alert-info">
                    <span>‚ÑπÔ∏è</span>
                    Choose a project to search its documents or upload new documents. PDFs will be automatically split into individual pages with optional OCR text extraction for full-text search capabilities.
                </div>
                <div class="project-grid" id="projectGrid">
                    <!-- Projects will be loaded here -->
                    <div class="empty-state">
                        <div class="empty-state-icon">üìÇ</div>
                        <h3>Loading projects...</h3>
                        <div class="loading"></div>
                    </div>
                </div>
            </div>

            <!-- Search Form -->
            <div class="search-form" id="searchForm">
                <div class="search-tabs">
                    <div class="search-tab active" data-tab="basic">üîç Basic Search</div>
                    <div class="search-tab" data-tab="advanced">‚öôÔ∏è Advanced Search</div>
                    <div class="search-tab" data-tab="fulltext">üìù Full-Text Search</div>
                </div>

                <!-- Basic Search Panel -->
                <div class="search-panel active" id="basicSearchPanel">
                    <h3>üîç Search Documents</h3>
                    <div class="search-fields" id="searchFields">
                        <!-- Dynamic search fields will be added here -->
                    </div>
                </div>

                <!-- Advanced Search Panel -->
                <div class="search-panel" id="advancedSearchPanel">
                    <h3>‚öôÔ∏è Advanced Search Options</h3>
                    <div class="advanced-search-fields" id="advancedSearchFields">
                        <div class="form-group">
                            <label for="advCreatedBy">Created By</label>
                            <input type="text" id="advCreatedBy" class="form-control" placeholder="Enter creator name">
                        </div>
                        <div class="form-group">
                            <label for="advDateRange">Date Range</label>
                            <div class="range-input">
                                <input type="date" id="advDateFrom" class="form-control">
                                <span>to</span>
                                <input type="date" id="advDateTo" class="form-control">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="advPageCount">Page Count</label>
                            <div class="range-input">
                                <input type="number" id="advPageCountMin" class="form-control" placeholder="Min">
                                <span>to</span>
                                <input type="number" id="advPageCountMax" class="form-control" placeholder="Max">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="advOCRStatus">OCR Status</label>
                            <select id="advOCRStatus" class="form-control">
                                <option value="">Any OCR Status</option>
                                <option value="true">Has OCR Text</option>
                                <option value="false">No OCR Text</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Full-Text Search Panel -->
                <div class="search-panel" id="fulltextSearchPanel">
                    <h3>üìù Full-Text Document Search</h3>
                    <div class="alert alert-info">
                        <span>üîç</span>
                        Search through OCR-extracted text content within documents. Use quotes for exact phrases, + for required words, - to exclude words.
                    </div>
                    <div class="form-group">
                        <label for="fulltextQuery">Search in document content</label>
                        <input type="text" id="fulltextQuery" class="form-control" placeholder="Enter keywords to search within document content...">
                        <small style="color: var(--text-light); margin-top: 0.5rem; display: block;">
                            Use quotes for exact phrases ("specific phrase"), + for required words (+required), - to exclude words (-exclude)
                        </small>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="searchTitles" checked> Include document titles and descriptions
                        </label>
                    </div>
                </div>

                <div class="search-actions">
                    <button class="btn btn-primary" onclick="performSearch()">
                        üîç Search Documents
                    </button>
                    <button class="btn btn-success" id="addDocumentBtn" onclick="showAddDocumentModal()" style="display: none;">
                        üì§ Add Document
                    </button>
                    <button class="btn btn-secondary" onclick="clearSearch()">
                        ‚ùå Clear Search
                    </button>
                    <span id="searchStatus" style="margin-left: 1rem; color: var(--text-light);"></span>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div class="results-section" id="resultsSection">
            <div class="results-header">
                <h3>üìã Search Results</h3>
                <div class="results-meta">
                    <div class="results-count" id="resultsCount">0 documents found</div>
                    <div class="view-options">
                        <button class="view-btn active" data-view="grid" onclick="changeView('grid')">‚äû</button>
                        <button class="view-btn" data-view="list" onclick="changeView('list')">‚ò∞</button>
                        <button class="view-btn" data-view="compact" onclick="changeView('compact')">‚ãØ</button>
                    </div>
                    <select id="sortOptions" class="form-control" style="width: auto;" onchange="sortResults()">
                        <option value="date_desc">Newest first</option>
                        <option value="date_asc">Oldest first</option>
                        <option value="title_asc">Title A-Z</option>
                        <option value="title_desc">Title Z-A</option>
                        <option value="relevance">Relevance (FTS)</option>
                    </select>
                </div>
            </div>
            <div class="document-grid" id="documentGrid">
                <!-- Search results will be displayed here -->
            </div>
        </div>
    </div>

    <!-- Document Viewer Modal -->
    <div id="documentModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalDocumentTitle">üìÑ Document Viewer</h3>
                <div class="modal-header-actions">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <!-- Document Info Toggle -->
                <div style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
                    <button class="info-toggle-btn active" id="infoToggleBtn" onclick="Documents.toggleDocumentInfo()">
                        üìÑ Hide Document Info
                    </button>
                </div>
                
                <div class="document-info" id="documentInfo">
                    <!-- Document information will be displayed here -->
                </div>

                <!-- OCR Controls -->
                <div class="ocr-controls" id="ocrControls" style="display: none;">
                    <h5>üîç OCR Processing</h5>
                    <div class="ocr-actions">
                        <button class="btn btn-info btn-sm" id="processDocumentOCRBtn" onclick="OCR.processDocument()">
                            üîÑ Process Document OCR
                        </button>
                        <button class="btn btn-warning btn-sm" id="reprocessDocumentOCRBtn" onclick="OCR.reprocessDocument()">
                            üîÑ Reprocess All Pages
                        </button>
                        <select id="ocrLanguage" class="form-control" style="width: auto;">
                            <option value="eng">English</option>
                            <option value="spa">Spanish</option>
                            <option value="fra">French</option>
                            <option value="deu">German</option>
                        </select>
                    </div>
                    <div class="ocr-stats" id="ocrStats" style="display: none;">
                        <div class="ocr-stats-grid">
                            <div class="ocr-stat">
                                <div class="ocr-stat-value" id="ocrPagesProcessed">0</div>
                                <div class="ocr-stat-label">Pages with OCR</div>
                            </div>
                            <div class="ocr-stat">
                                <div class="ocr-stat-value" id="ocrTotalWords">0</div>
                                <div class="ocr-stat-label">Total Words</div>
                            </div>
                            <div class="ocr-stat">
                                <div class="ocr-stat-value" id="ocrAvgConfidence">0%</div>
                                <div class="ocr-stat-label">Avg Confidence</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Page Viewer Section -->
                <div class="page-viewer" id="pageViewer">
                    <div class="page-viewer-header">
                        <h4>üìë Document Pages</h4>
                        <div class="viewer-controls">
                            <button class="index-toggle-btn" id="indexToggleBtn" onclick="Documents.toggleIndexInfo()">
                                üìã Show Index Info
                            </button>
                            <button class="index-toggle-btn" id="ocrToggleBtn" onclick="Documents.toggleOCRInfo()">
                                üîç Show OCR Info
                            </button>
                            <button class="btn btn-info btn-sm" id="toggleOCRControlsBtn" onclick="Documents.toggleOCRControls()">
                                üîß OCR Controls
                            </button>
                            <button class="btn btn-warning btn-sm" id="reorderToggleBtn" onclick="Documents.toggleReorderMode()" style="display: none;">
                                üîÑ Reorder Pages
                            </button>
                            <button class="btn btn-success btn-sm" id="saveReorderBtn" onclick="Documents.savePageOrder()" style="display: none;">
                                üíæ Save Order
                            </button>
                            <button class="btn btn-secondary btn-sm" id="cancelReorderBtn" onclick="Documents.cancelReorder()" style="display: none;">
                                ‚ùå Cancel
                            </button>
                            <button class="btn btn-info btn-sm" id="addPagesBtn" onclick="Documents.showAddPagesDropZone()" style="display: none;">
                                üì§ Add Pages
                            </button>
                        </div>
                    </div>
                    
                    <!-- Add Pages Drop Zone -->
                    <div class="add-pages-drop-zone hidden" id="addPagesDropZone">
                        <div class="drop-zone-content">
                            <div class="drop-zone-icon">üìÅ</div>
                            <h5>Add New Pages to Document</h5>
                            <p>Drag and drop PDF or image files here to add new pages</p>
                            <p class="drop-zone-hint">Supported formats: PDF (auto-split), JPG, PNG, TIFF</p>
                            <div class="ocr-option">
                                <label>
                                    <input type="checkbox" id="addPagesOCR" checked>
                                    üîç Process OCR on uploaded pages
                                </label>
                            </div>
                            <div class="drop-zone-actions">
                                <button class="btn btn-primary btn-sm" onclick="document.getElementById('addPagesFileInput').click()">
                                    üìÅ Browse Files
                                </button>
                                <button class="btn btn-secondary btn-sm" onclick="Documents.hideAddPagesDropZone()">
                                    ‚ùå Cancel
                                </button>
                            </div>
                            <input type="file" id="addPagesFileInput" multiple accept=".pdf,.jpg,.jpeg,.png,.tiff,.tif" style="display: none;">
                        </div>
                        <div class="upload-progress hidden" id="uploadProgress">
                            <div class="progress-info">
                                <span id="uploadStatus">Uploading...</span>
                                <span id="uploadPercent">0%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill"></div>
                            </div>
                        </div>
                    </div>

                    <div class="page-grid" id="pageGrid">
                        <!-- Document pages will be displayed here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Document Modal -->
    <div id="addDocumentModal" class="modal upload-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üì§ Add New Document</h3>
                <button class="close-btn" onclick="closeAddDocumentModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="addDocumentForm" class="upload-form">
                    <!-- Basic Information -->
                    <div class="form-group">
                        <label for="docTitle">Document Title *</label>
                        <input type="text" id="docTitle" class="form-control" required placeholder="Title will be set automatically from filename">
                        <small style="color: var(--text-light); margin-top: 0.5rem; display: block;">
                            üìù The title will automatically be set to the first uploaded file's name. You can modify it if needed.
                        </small>
                    </div>

                    <!-- Dynamic Index Fields -->
                    <div id="indexFieldsContainer">
                        <h4 style="color: var(--primary-color); margin-bottom: 1rem;">üìù Index Fields</h4>
                        <div id="dynamicIndexFields">
                            <!-- Dynamic fields will be added here based on selected project -->
                        </div>
                    </div>

                    <!-- File Upload -->
                    <div class="form-group">
                        <label>Upload Files</label>
                        <div class="alert alert-info" style="margin-bottom: 1rem;">
                            <span>üîÑ</span>
                            <strong>Enhanced Document Processing:</strong> Upload your files with automatic OCR text extraction for searchable content. PDFs will be split into individual pages, and you can process OCR on all uploaded content for full-text search capabilities.
                        </div>
                        <div class="file-upload-area" id="fileUploadArea">
                            <input type="file" id="fileInput" multiple accept=".pdf,.jpg,.jpeg,.png,.tiff,.tif">
                            <div class="upload-icon">üìÅ</div>
                            <p><strong>Click to select files</strong> or drag and drop here</p>
                            <p style="font-size: 0.9rem; color: var(--text-light);">
                                Supported formats: PDF (auto-split), JPG, PNG, TIFF
                            </p>
                        </div>
                        
                        <!-- OCR Option -->
                        <div class="ocr-option">
                            <label>
                                <input type="checkbox" id="uploadOCR" checked>
                                üîç Process OCR on uploaded files for text extraction and search
                            </label>
                        </div>
                        
                        <div id="fileList" class="file-list"></div>
                    </div>

                    <!-- Submit Actions -->
                    <div style="display: flex; gap: 1rem; justify-content: flex-end; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                        <button type="button" class="btn btn-secondary" onclick="closeAddDocumentModal()">
                            ‚ùå Cancel
                        </button>
                        <button type="submit" class="btn btn-success" id="submitDocumentBtn">
                            <span id="submitDocumentBtnText">üíæ Save Document</span>
                            <span id="submitDocumentLoader" class="loading hidden"></span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
        // Application State
        const AppState = {
            currentUser: null,
            token: null,
            projects: [],
            selectedProject: null,
            documents: [],
            searchResults: [],
            fulltextResults: [],
            currentDocument: null,
            currentView: 'grid',
            uploadFiles: [],
            isSubmitting: false,
            lastSearchType: 'basic',
            apiBase: 'http://localhost:3000/api'
        };

        // API Client
        const API = {
            getHeaders() {
                const headers = {
                    'Content-Type': 'application/json',
                };
                
                if (AppState.token) {
                    headers['Authorization'] = `Bearer ${AppState.token}`;
                }
                
                return headers;
            },

            async request(endpoint, options = {}) {
                try {
                    const url = `${AppState.apiBase}${endpoint}`;
                    const config = {
                        ...options,
                        headers: {
                            ...this.getHeaders(),
                            ...options.headers
                        }
                    };

                    const response = await fetch(url, config);
                    
                    if (!response.ok) {
                        let errorData;
                        try {
                            errorData = await response.json();
                        } catch (e) {
                            errorData = { error: `HTTP ${response.status}: ${response.statusText}` };
                        }
                        
                        let errorMessage = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
                        
                        if (response.status === 403) {
                            errorMessage = `Access denied: ${errorData.error || 'You may not have permission for this action'}`;
                        } else if (response.status === 401) {
                            errorMessage = `Authentication failed: ${errorData.error || 'Please log in again'}`;
                            logout();
                        } else if (response.status === 404) {
                            errorMessage = `Not found: ${errorData.error || 'The requested resource was not found'}`;
                        }
                        
                        throw new Error(errorMessage);
                    }
                    
                    return response;
                } catch (error) {
                    console.error('API Request failed:', error);
                    if (error.message.includes('fetch')) {
                        throw new Error('Network error: Unable to connect to server. Please check your connection and ensure the server is running on http://localhost:3000');
                    }
                    throw error;
                }
            },

            async get(endpoint) {
                const response = await this.request(endpoint);
                return response.json();
            },

            async post(endpoint, data) {
                const response = await this.request(endpoint, {
                    method: 'POST',
                    body: JSON.stringify(data),
                });
                return response.json();
            },

            async uploadFile(endpoint, formData) {
                const headers = {};
                if (AppState.token) {
                    headers['Authorization'] = `Bearer ${AppState.token}`;
                }

                const response = await fetch(`${AppState.apiBase}${endpoint}`, {
                    method: 'POST',
                    headers,
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Upload failed');
                }

                return response.json();
            },

            async put(endpoint, data) {
                const response = await this.request(endpoint, {
                    method: 'PUT',
                    body: JSON.stringify(data),
                });
                return response.json();
            },

            async delete(endpoint) {
                const response = await this.request(endpoint, {
                    method: 'DELETE',
                });
                return response.json();
            }
        };

 };

        // Authentication Module
        const Auth = {
            async login(username, password) {
                try {
                    Utils.setLoading('loginBtn', true);
                    
                    const data = await API.post('/auth/login', { username, password });
                    
                    AppState.token = data.token;
                    AppState.currentUser = data.user;
                    
                    if (typeof(Storage) !== "undefined") {
                        localStorage.setItem('dms_token', data.token);
                    }
                    
                    this.showMainApp();
                    Utils.showToast('Welcome back!', 'success');
                    
                } catch (error) {
                    console.error('Login error:', error);
                    this.showError('loginError', error.message || 'Login failed');
                } finally {
                    Utils.setLoading('loginBtn', false);
                }
            },

            async validateToken() {
                try {
                    const storedToken = localStorage.getItem('dms_token');
                    if (!storedToken) return false;
                    
                    AppState.token = storedToken;
                    const data = await API.get('/auth/validate');
                    
                    AppState.currentUser = data.user;
                    return true;
                } catch (error) {
                    console.error('Token validation failed:', error);
                    if (typeof(Storage) !== "undefined") {
                        localStorage.removeItem('dms_token');
                    }
                    return false;
                }
            },

            logout() {
                AppState.token = null;
                AppState.currentUser = null;
                if (typeof(Storage) !== "undefined") {
                    localStorage.removeItem('dms_token');
                }
                this.showLogin();
                Utils.showToast('Logged out successfully', 'info');
            },

            showLogin() {
                document.getElementById('loginScreen').classList.remove('hidden');
                document.getElementById('mainApp').classList.add('hidden');
            },

            showMainApp() {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('mainApp').classList.remove('hidden');
                this.updateUserInfo();
                this.updateAdminControls();
                Projects.load();
            },

            updateUserInfo() {
                const user = AppState.currentUser;
                const displayName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.username;
                
                document.getElementById('userDisplay').textContent = displayName;
                document.getElementById('userRole').textContent = user.role_name || 'No Role';
                document.getElementById('userAvatar').textContent = Utils.generateAvatar(displayName);
            },

            updateAdminControls() {
                const user = AppState.currentUser;
                const hasAdminAccess = user.permissions && user.permissions.includes('admin_access');
                
                if (hasAdminAccess) {
                    document.getElementById('adminControls').classList.remove('hidden');
                    document.getElementById('regularControls').classList.add('hidden');
                } else {
                    document.getElementById('adminControls').classList.add('hidden');
                    document.getElementById('regularControls').classList.remove('hidden');
                }
            },

            showError(elementId, message) {
                const element = document.getElementById(elementId);
                element.textContent = message;
                element.classList.remove('hidden');
                
                setTimeout(() => {
                    element.classList.add('hidden');
                }, 5000);
            }
        };

        // Project Management
        const Projects = {
            async load() {
                try {
                    const container = document.getElementById('projectGrid');
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÇ</div>
                            <h3>Loading projects...</h3>
                            <div class="loading"></div>
                        </div>
                    `;
                    
                    const projects = await API.get('/projects');
                    AppState.projects = projects;
                    
                    this.display(projects);
                    
                } catch (error) {
                    console.error('Projects load error:', error);
                    Utils.showToast('Failed to load projects: ' + error.message, 'error');
                    this.showError();
                }
            },

            display(projects) {
                const container = document.getElementById('projectGrid');
                
                if (projects.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÇ</div>
                            <h3>No projects available</h3>
                            <p>Contact your administrator to set up document projects.</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = projects.map(project => `
                    <div class="project-card" 
                         data-project-id="${project.id}" 
                         style="--project-color: ${project.color || '#667eea'}"
                         onclick="Projects.select(${project.id})">
                        <div class="project-title">
                            ${Utils.getProjectTypeIcon(project.type)} ${Utils.sanitizeInput(project.name)}
                        </div>
                        <div class="project-description">
                            ${Utils.sanitizeInput(project.description || 'No description')}
                        </div>
                        <div class="project-stats">
                            <span>üìÑ ${project.document_count || 0} documents</span>
                            <span>üîç ${project.index_fields?.length || 0} search fields</span>
                        </div>
                        <div class="project-actions">
                            <button class="btn btn-success btn-sm" onclick="event.stopPropagation(); showAddDocumentModal()">
                                üì§ Add Document
                            </button>
                        </div>
                    </div>
                `).join('');
            },

            showError() {
                const container = document.getElementById('projectGrid');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ùå</div>
                        <h3>Failed to load projects</h3>
                        <p>Please check your connection and try again.</p>
                        <button class="btn btn-primary" onclick="Projects.load()">Retry</button>
                    </div>
                `;
            },

            select(projectId) {
                document.querySelectorAll('.project-card').forEach(card => {
                    card.classList.remove('selected');
                });

                const projectCard = document.querySelector(`[data-project-id="${projectId}"]`);
                projectCard.classList.add('selected');

                AppState.selectedProject = AppState.projects.find(p => p.id === projectId);
                
                this.setupSearchForm();
                
                const addDocBtn = document.getElementById('addDocumentBtn');
                if (AppState.currentUser.permissions.includes('document_create') || AppState.currentUser.permissions.includes('admin_access')) {
                    addDocBtn.style.display = 'inline-flex';
                }
                
                Search.clearResults();
                
                Utils.showToast(`Selected project: ${AppState.selectedProject.name}`, 'success');
            },

            setupSearchForm() {
                const searchForm = document.getElementById('searchForm');
                const searchFields = document.getElementById('searchFields');
                
                if (!AppState.selectedProject) {
                    searchForm.classList.remove('active');
                    return;
                }

                searchFields.innerHTML = AppState.selectedProject.index_fields.map(field => `
                    <div class="form-group">
                        <label for="search_${field.name}">${Utils.sanitizeInput(field.label)}</label>
                        ${this.createSearchInput(field)}
                    </div>
                `).join('');

                searchForm.classList.add('active');
            },

            createSearchInput(field) {
                const id = `search_${field.name}`;
                
                switch (field.type) {
                    case 'dropdown':
                        return `
                            <select id="${id}" class="form-control">
                                <option value="">Any ${field.label}</option>
                                ${(field.options || []).map(opt => 
                                    `<option value="${Utils.sanitizeInput(opt)}">${Utils.sanitizeInput(opt)}</option>`
                                ).join('')}
                            </select>
                        `;
                    case 'date':
                        return `
                            <div class="range-input">
                                <input type="date" id="${id}_from" class="form-control">
                                <span>to</span>
                                <input type="date" id="${id}_to" class="form-control">
                            </div>
                        `;
                    case 'number':
                        return `
                            <div class="range-input">
                                <input type="number" id="${id}_min" class="form-control" placeholder="Min ${field.label.toLowerCase()}">
                                <span>to</span>
                                <input type="number" id="${id}_max" class="form-control" placeholder="Max ${field.label.toLowerCase()}">
                            </div>
                        `;
                    default:
                        return `<input type="text" id="${id}" class="form-control" placeholder="Enter ${field.label.toLowerCase()}">`;
                }
            }
        };

        // Enhanced Search Management with Full-Text Search
        const Search = {
            currentTab: 'basic',

            switchTab(tabName) {
                document.querySelectorAll('.search-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });

                document.querySelectorAll('.search-panel').forEach(panel => {
                    panel.classList.toggle('active', panel.id === `${tabName}SearchPanel`);
                });

                this.currentTab = tabName;
            },

            async perform() {
                if (!AppState.selectedProject) {
                    Utils.showToast('Please select a project first', 'warning');
                    return;
                }

                document.getElementById('searchStatus').innerHTML = '<span class="loading"></span> Searching...';
                AppState.lastSearchType = this.currentTab;

                try {
                    if (this.currentTab === 'fulltext') {
                        await this.performFullTextSearch();
                    } else {
                        await this.performIndexSearch();
                    }
                    
                } catch (error) {
                    console.error('Search failed:', error);
                    Utils.showToast('Search failed: ' + error.message, 'error');
                } finally {
                    setTimeout(() => {
                        document.getElementById('searchStatus').textContent = '';
                    }, 2000);
                }
            },

            async performFullTextSearch() {
                const query = document.getElementById('fulltextQuery').value.trim();
                const searchTitles = document.getElementById('searchTitles').checked;
                
                if (!query) {
                    Utils.showToast('Please enter a search query', 'warning');
                    return;
                }

                try {
                    // Use the new backend full-text search endpoint
                    const searchParams = new URLSearchParams({
                        q: query,
                        project_id: AppState.selectedProject.id,
                        limit: 50,
                        offset: 0
                    });

                    const results = await API.get(`/search?${searchParams}`);
                    
                    // Transform FTS results to match document format
                    const documents = await this.transformFTSResults(results);
                    
                    AppState.fulltextResults = results.results;
                    AppState.searchResults = documents;
                    this.displayResults(documents, query);
                    
                    Utils.showToast(`Found ${results.total} matching pages in ${documents.length} documents`, 'success');
                    
                } catch (error) {
                    console.error('Full-text search failed:', error);
                    Utils.showToast('Full-text search failed: ' + error.message, 'error');
                }
            },

            async transformFTSResults(ftsResults) {
                // Group FTS results by document and transform to document format
                const documentsMap = new Map();
                
                for (const result of ftsResults.results) {
                    if (!documentsMap.has(result.document_id)) {
                        // Fetch document details if not cached
                        try {
                            const doc = await API.get(`/documents/${result.document_id}`);
                            doc.search_matches = [];
                            documentsMap.set(result.document_id, doc);
                        } catch (error) {
                            console.warn(`Failed to fetch document ${result.document_id}:`, error);
                            continue;
                        }
                    }
                    
                    const doc = documentsMap.get(result.document_id);
                    doc.search_matches.push({
                        page_number: result.page_number,
                        snippet: result.snippet,
                        relevance: result.relevance
                    });
                }
                
                return Array.from(documentsMap.values());
            },

            async performIndexSearch() {
                const documents = await API.get(`/projects/${AppState.selectedProject.id}/documents`);
                
                let filteredDocuments = documents;
                const criteria = this.getSearchCriteria();
                
                if (Object.keys(criteria).length > 0) {
                    filteredDocuments = this.filterDocuments(documents, criteria);
                }
                
                AppState.searchResults = filteredDocuments;
                this.displayResults(filteredDocuments);
                
                Utils.showToast(`Found ${filteredDocuments.length} documents`, 'success');
            },

            getSearchCriteria() {
                const criteria = {};
                
                if (this.currentTab === 'basic' || this.currentTab === 'advanced') {
                    const container = document.getElementById('searchFields');
                    container.querySelectorAll('.form-control').forEach(input => {
                        if (input.value.trim()) {
                            const fieldName = input.id.replace('search_', '').replace(/_from|_to|_min|_max/, '');
                            if (!criteria[fieldName]) criteria[fieldName] = {};
                            
                            if (input.id.includes('_from')) {
                                criteria[fieldName].from = input.value.trim();
                            } else if (input.id.includes('_to')) {
                                criteria[fieldName].to = input.value.trim();
                            } else if (input.id.includes('_min')) {
                                criteria[fieldName].min = input.value.trim();
                            } else if (input.id.includes('_max')) {
                                criteria[fieldName].max = input.value.trim();
                            } else {
                                criteria[fieldName] = input.value.trim();
                            }
                        }
                    });
                }
                
                if (this.currentTab === 'advanced') {
                    const createdBy = document.getElementById('advCreatedBy').value.trim();
                    if (createdBy) criteria.created_by = createdBy;
                    
                    const dateFrom = document.getElementById('advDateFrom').value;
                    const dateTo = document.getElementById('advDateTo').value;
                    if (dateFrom || dateTo) {
                        criteria.created_date = {};
                        if (dateFrom) criteria.created_date.from = dateFrom;
                        if (dateTo) criteria.created_date.to = dateTo;
                    }
                    
                    const pageCountMin = document.getElementById('advPageCountMin').value;
                    const pageCountMax = document.getElementById('advPageCountMax').value;
                    if (pageCountMin || pageCountMax) {
                        criteria.page_count = {};
                        if (pageCountMin) criteria.page_count.min = parseInt(pageCountMin);
                        if (pageCountMax) criteria.page_count.max = parseInt(pageCountMax);
                    }

                    const ocrStatus = document.getElementById('advOCRStatus').value;
                    if (ocrStatus) {
                        criteria.has_ocr_text = ocrStatus === 'true';
                    }
                }
                
                return criteria;
            },

            filterDocuments(documents, criteria) {
                if (Object.keys(criteria).length === 0) {
                    return documents;
                }

                return documents.filter(doc => {
                    return Object.entries(criteria).every(([field, value]) => {
                        if (field === 'created_by') {
                            return doc.created_by_name?.toLowerCase().includes(value.toLowerCase());
                        }

                        if (field === 'created_date') {
                            const docDate = new Date(doc.created_at);
                            if (value.from && docDate < new Date(value.from)) return false;
                            if (value.to && docDate > new Date(value.to)) return false;
                            return true;
                        }

                        if (field === 'page_count') {
                            const pageCount = doc.page_count || doc.total_pages || 0;
                            if (value.min && pageCount < value.min) return false;
                            if (value.max && pageCount > value.max) return false;
                            return true;
                        }

                        if (field === 'has_ocr_text') {
                            return doc.has_ocr_text === value;
                        }

                        const docValue = doc.index_values?.[field];
                        if (!docValue) return false;

                        if (typeof value === 'object') {
                            if (value.from || value.to || value.min || value.max) {
                                const numValue = parseFloat(docValue);
                                if (value.min && numValue < parseFloat(value.min)) return false;
                                if (value.max && numValue > parseFloat(value.max)) return false;
                                if (value.from && new Date(docValue) < new Date(value.from)) return false;
                                if (value.to && new Date(docValue) > new Date(value.to)) return false;
                                return true;
                            }
                        } else {
                            if (typeof docValue === 'string') {
                                return docValue.toLowerCase().includes(value.toLowerCase());
                            } else if (typeof docValue === 'number') {
                                return docValue.toString().includes(value);
                            } else {
                                return docValue.toString() === value;
                            }
                        }

                        return true;
                    });
                });
            },

            displayResults(results, searchQuery = null) {
                const resultsSection = document.getElementById('resultsSection');
                const documentGrid = document.getElementById('documentGrid');
                const resultsCount = document.getElementById('resultsCount');
                
                let countText = `${results.length} document${results.length !== 1 ? 's' : ''} found`;
                if (AppState.lastSearchType === 'fulltext' && AppState.fulltextResults) {
                    countText += ` (${AppState.fulltextResults.length} matching pages)`;
                }
                resultsCount.textContent = countText;
                
                if (results.length === 0) {
                    documentGrid.innerHTML = `
                        <div class="no-results">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">üîç</div>
                            <h3>No documents found</h3>
                            <p>Try adjusting your search criteria or clearing some filters.</p>
                            <button class="btn btn-outline" onclick="clearSearch()">Clear Search</button>
                        </div>
                    `;
                } else {
                    documentGrid.innerHTML = results.map(doc => this.createDocumentCard(doc, searchQuery)).join('');
                }
                
                resultsSection.classList.add('active');
            },

            createDocumentCard(doc, searchQuery = null) {
                const pageCount = doc.page_count || doc.total_pages || 0;
                const hasOCR = doc.has_ocr_text;
                
                // Create search snippets for full-text search results
                let searchSnippets = '';
                if (doc.search_matches && doc.search_matches.length > 0) {
                    searchSnippets = `
                        <div class="search-result-snippet">
                            <strong>üìÑ Found in ${doc.search_matches.length} page${doc.search_matches.length !== 1 ? 's' : ''}:</strong><br>
                            ${doc.search_matches.slice(0, 2).map(match => 
                                `<div style="margin: 0.25rem 0;">Page ${match.page_number}: ${match.snippet}</div>`
                            ).join('')}
                            ${doc.search_matches.length > 2 ? `<div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-light);">+${doc.search_matches.length - 2} more matches</div>` : ''}
                        </div>
                    `;
                }
                
                return `
                    <div class="document-card ${AppState.currentView}-view" onclick="Documents.view(${doc.id})">
                        <div class="document-header">
                            <div class="document-title">
                                ${Utils.getFileTypeIcon(doc.title)} ${Utils.sanitizeInput(doc.title)}
                                <span class="ocr-status ${hasOCR ? 'has-ocr' : 'no-ocr'}">
                                    ${hasOCR ? 'üîç OCR' : 'üìÑ No OCR'}
                                </span>
                            </div>
                            <div class="document-actions">
                                <button class="btn btn-outline btn-sm" onclick="event.stopPropagation(); quickDownload(${doc.id})" title="Quick Download">‚¨áÔ∏è</button>
                                <button class="btn btn-outline btn-sm" onclick="event.stopPropagation(); toggleQuickFavorite(${doc.id})" title="Toggle Favorite">‚òÜ</button>
                                ${Documents.canDeleteDocument() ? `
                                    <button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); Documents.delete(${doc.id}, '${Utils.sanitizeInput(doc.title).replace(/'/g, "\\'")}', true)" title="Delete Document">üóëÔ∏è</button>
                                ` : ''}
                            </div>
                        </div>
                        <div class="document-description">
                            ${Utils.sanitizeInput(doc.description || 'No description')}
                        </div>
                        ${searchSnippets}
                        <div class="document-fields">
                            ${Object.entries(doc.index_values || {}).slice(0, 3).map(([key, value]) => {
                                let displayValue = value;
                                
                                const field = AppState.selectedProject?.index_fields?.find(f => f.name === key);
                                if (field) {
                                    if (field.type === 'number' && (key.includes('amount') || key.includes('value'))) {
                                        displayValue = Utils.formatCurrency(parseFloat(value));
                                    } else if (field.type === 'date') {
                                        displayValue = Utils.formatDate(value);
                                    }
                                }
                                
                                return `
                                    <div class="field-row">
                                        <span class="field-label">${Utils.sanitizeInput(key.replace('_', ' '))}:</span>
                                        <span class="field-value">${Utils.sanitizeInput(displayValue)}</span>
                                    </div>
                                `;
                            }).join('')}
                            ${Object.keys(doc.index_values || {}).length > 3 ? 
                                `<div class="field-row">
                                    <span class="field-label">+${Object.keys(doc.index_values).length - 3} more fields</span>
                                </div>` : ''}
                        </div>
                        <div class="document-meta">
                            <span>üë§ ${Utils.sanitizeInput(doc.created_by_name || 'Unknown')}</span>
                            <span>üìÑ ${pageCount} page${pageCount !== 1 ? 's' : ''}</span>
                            <span>üìÖ ${Utils.formatDate(doc.created_at)}</span>
                        </div>
                    </div>
                `;
            },

            clear() {
                document.querySelectorAll('.search-panel .form-control').forEach(input => {
                    if (input.type === 'checkbox') {
                        input.checked = input.id === 'searchTitles';
                    } else {
                        input.value = '';
                    }
                });
                
                this.clearResults();
                
                Utils.showToast('Search cleared', 'info');
            },

            clearResults() {
                const resultsSection = document.getElementById('resultsSection');
                resultsSection.classList.remove('active');
                AppState.searchResults = [];
                AppState.fulltextResults = [];
            }
        };

        // OCR Management Module
        const OCR = {
            async processDocument() {
                if (!AppState.currentDocument) {
                    Utils.showToast('No document selected', 'error');
                    return;
                }

                const language = document.getElementById('ocrLanguage').value || 'eng';
                const confirmProcess = confirm(`Process OCR for all pages in this document?\n\nThis will extract text from all pages for search capabilities. This may take some time depending on the number of pages.`);
                
                if (!confirmProcess) return;

                try {
                    Utils.showToast('Starting OCR processing...', 'info');
                    
                    const result = await API.post(`/documents/${AppState.currentDocument.id}/ocr`, {
                        language: language,
                        force_reprocess: false
                    });

                    Utils.showToast(`OCR processing completed! Processed ${result.processed_pages} pages with ${result.total_words} total words extracted.`, 'success');
                    
                    // Update document info and refresh page display
                    await this.refreshDocumentOCRInfo();
                    
                } catch (error) {
                    Utils.showToast('OCR processing failed: ' + error.message, 'error');
                }
            },

            async reprocessDocument() {
                if (!AppState.currentDocument) {
                    Utils.showToast('No document selected', 'error');
                    return;
                }

                const language = document.getElementById('ocrLanguage').value || 'eng';
                const confirmReprocess = confirm(`Reprocess OCR for ALL pages in this document?\n\nThis will overwrite existing OCR text. This operation may take some time.`);
                
                if (!confirmReprocess) return;

                try {
                    Utils.showToast('Starting OCR reprocessing...', 'info');
                    
                    const result = await API.post(`/documents/${AppState.currentDocument.id}/ocr`, {
                        language: language,
                        force_reprocess: true
                    });

                    Utils.showToast(`OCR reprocessing completed! Processed ${result.processed_pages} pages with ${result.total_words} total words extracted.`, 'success');
                    
                    // Update document info and refresh page display
                    await this.refreshDocumentOCRInfo();
                    
                } catch (error) {
                    Utils.showToast('OCR reprocessing failed: ' + error.message, 'error');
                }
            },

            async processPage(pageId) {
                const language = document.getElementById('ocrLanguage').value || 'eng';
                
                try {
                    Utils.showToast(`Processing OCR for page...`, 'info');
                    
                    const result = await API.post(`/pages/${pageId}/ocr`, {
                        language: language
                    });

                    Utils.showToast(`OCR completed! Found ${result.word_count} words with ${result.ocr_confidence}% confidence.`, 'success');
                    
                    // Refresh the page display to show OCR status
                    await Documents.refreshPageDisplay();
                    
                } catch (error) {
                    Utils.showToast('Page OCR processing failed: ' + error.message, 'error');
                }
            },

            async getPageOCRText(pageId) {
                try {
                    const result = await API.get(`/pages/${pageId}/ocr`);
                    return result;
                } catch (error) {
                    console.error('Failed to get OCR text:', error);
                    return null;
                }
            },

            async refreshDocumentOCRInfo() {
                try {
                    const documentData = await API.get(`/documents/${AppState.currentDocument.id}`);
                    const pages = await API.get(`/documents/${AppState.currentDocument.id}/pages`);
                    
                    AppState.currentDocument = documentData;
                    Documents.renderDocumentInfo(documentData);
                    Documents.updateOCRStats(pages);
                    Documents.displayPages(pages, document.getElementById('pageGrid'));
                    
                } catch (error) {
                    console.error('Failed to refresh OCR info:', error);
                }
            }
        };

        // Enhanced Document Management with OCR Integration
        const Documents = {
            isEditing: false,
            showIndexInfo: false,
            showOCRInfo: false,
            showDocumentInfo: true,
            isReorderMode: false,
            originalPageOrder: [],
            currentPages: [],
            
            async view(documentId) {
                try {
                    Utils.showToast('Loading document...', 'info');
                    
                    const documentData = await API.get(`/documents/${documentId}`);
                    const pages = await API.get(`/documents/${documentId}/pages`);
                    
                    AppState.currentDocument = documentData;
                    this.isEditing = false;
                    this.showModal(documentData, pages);
                    
                } catch (error) {
                    Utils.showToast('Failed to load document: ' + error.message, 'error');
                }
            },

            showModal(documentData, pages) {
                const modal = document.getElementById('documentModal');
                const title = document.getElementById('modalDocumentTitle');
                const info = document.getElementById('documentInfo');
                const pageGrid = document.getElementById('pageGrid');
                
                // Reset toggle states for new document
                this.showIndexInfo = false;
                this.showOCRInfo = false;
                this.showDocumentInfo = true;
                this.isReorderMode = false;
                this.originalPageOrder = [];
                this.currentPages = [];
                
                // Update modal header with edit buttons
                const modalHeader = title.parentElement;
                modalHeader.innerHTML = `
                    <h3 id="modalDocumentTitle">${Utils.getFileTypeIcon(documentData.title)} ${documentData.title}</h3>
                    <div class="modal-header-actions">
                        ${this.canEditDocument() ? `
                            <button id="editDocumentBtn" class="btn btn-outline btn-sm" onclick="Documents.toggleEdit()" style="display: ${this.isEditing ? 'none' : 'inline-flex'}; color: white; border-color: white;">
                                ‚úèÔ∏è Edit Fields
                            </button>
                            <button id="saveDocumentBtn" class="btn btn-success btn-sm" onclick="Documents.saveChanges()" style="display: ${this.isEditing ? 'inline-flex' : 'none'};">
                                üíæ Save Changes
                            </button>
                            <button id="cancelEditBtn" class="btn btn-secondary btn-sm" onclick="Documents.cancelEdit()" style="display: ${this.isEditing ? 'inline-flex' : 'none'};">
                                ‚ùå Cancel
                            </button>
                        ` : ''}
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                    </div>
                `;
                
                // Display document information
                this.renderDocumentInfo(documentData);
                
                // Reset and update the toggle buttons
                const infoToggleBtn = document.getElementById('infoToggleBtn');
                if (infoToggleBtn) {
                    infoToggleBtn.textContent = 'üìÑ Hide Document Info';
                    infoToggleBtn.classList.add('active');
                }
                
                const indexToggleBtn = document.getElementById('indexToggleBtn');
                if (indexToggleBtn) {
                    indexToggleBtn.textContent = 'üìã Show Index Info';
                    indexToggleBtn.classList.remove('active');
                }

                const ocrToggleBtn = document.getElementById('ocrToggleBtn');
                if (ocrToggleBtn) {
                    ocrToggleBtn.textContent = 'üîç Show OCR Info';
                    ocrToggleBtn.classList.remove('active');
                }
                
                // Show/hide control buttons based on permissions
                const addPagesBtn = document.getElementById('addPagesBtn');
                const toggleOCRControlsBtn = document.getElementById('toggleOCRControlsBtn');
                
                if (addPagesBtn && this.canEditDocument()) {
                    addPagesBtn.style.display = 'inline-flex';
                }
                
                if (toggleOCRControlsBtn && this.canProcessOCR()) {
                    toggleOCRControlsBtn.style.display = 'inline-flex';
                }
                
                // Initialize OCR controls
                this.initializeOCRControls();
                this.updateOCRStats(pages);
                
                // Initialize add pages functionality
                this.initializeAddPagesDropZone();
                
                // Display pages
                this.displayPages(pages, pageGrid);
                
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            },

            renderDocumentInfo(documentData) {
                const info = document.getElementById('documentInfo');
                const hasOCR = documentData.has_ocr_text;
                
                info.innerHTML = `
                    <h4>Document Information</h4>
                    <div class="info-grid">
                        <div class="info-item">
                            <div class="info-label">Title</div>
                            <div class="info-value">${Utils.sanitizeInput(documentData.title)}</div>
                        </div>
                        ${documentData.description ? `
                        <div class="info-item">
                            <div class="info-label">Description</div>
                            <div class="info-value">${Utils.sanitizeInput(documentData.description)}</div>
                        </div>
                        ` : ''}
                        <div class="info-item">
                            <div class="info-label">Project</div>
                            <div class="info-value">${Utils.sanitizeInput(documentData.project_name || 'Unknown')}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Created By</div>
                            <div class="info-value">${Utils.sanitizeInput(documentData.created_by_name || 'Unknown')}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Created Date</div>
                            <div class="info-value">${Utils.formatDate(documentData.created_at)}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Total Pages</div>
                            <div class="info-value">${AppState.currentDocument?.page_count || 0}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">OCR Status</div>
                            <div class="info-value">
                                <span class="ocr-status ${hasOCR ? 'has-ocr' : 'no-ocr'}">
                                    ${hasOCR ? 'üîç Text Extracted' : 'üìÑ No OCR Data'}
                                </span>
                            </div>
                        </div>
                        ${documentData.ocr_completed_at ? `
                        <div class="info-item">
                            <div class="info-label">OCR Completed</div>
                            <div class="info-value">${Utils.formatDate(documentData.ocr_completed_at)}</div>
                        </div>
                        ` : ''}
                    </div>
                    
                    <h4 style="margin-top: 2rem; margin-bottom: 1rem;">Index Field Values</h4>
                    <div id="indexFieldsContainer">
                        ${this.renderIndexFields(documentData)}
                    </div>
                `;
            },

            renderIndexFields(documentData) {
                if (!AppState.selectedProject?.index_fields || AppState.selectedProject.index_fields.length === 0) {
                    return '<p style="color: var(--text-light);">No index fields configured for this project.</p>';
                }

                return `
                    <div class="info-grid" id="indexFieldsGrid">
                        ${AppState.selectedProject.index_fields.map(field => {
                            const value = documentData.index_values?.[field.name] || '';
                            let displayValue = value;
                            
                            // Format display value based on field type
                            if (field.type === 'number' && (field.name.includes('amount') || field.name.includes('value'))) {
                                displayValue = value ? Utils.formatCurrency(parseFloat(value)) : '';
                            } else if (field.type === 'date' && value) {
                                displayValue = Utils.formatDate(value);
                            }
                            
                            const fieldLabel = Utils.sanitizeInput(field.label.replace(/\b\w/g, l => l.toUpperCase()));
                            
                            return `
                                <div class="info-item" data-field="${field.name}">
                                    <div class="info-label">${fieldLabel}</div>
                                    <div class="info-value" id="display_${field.name}" style="display: ${this.isEditing ? 'none' : 'block'};">
                                        ${Utils.sanitizeInput(displayValue || 'Not set')}
                                    </div>
                                    <div class="info-edit" id="edit_${field.name}" style="display: ${this.isEditing ? 'block' : 'none'};">
                                        ${this.createEditInput(field, value)}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            },

            createEditInput(field, value) {
                const id = `input_${field.name}`;
                const required = field.required ? 'required' : '';
                
                switch (field.type) {
                    case 'dropdown':
                        return `
                            <select id="${id}" class="form-control" ${required}>
                                <option value="">Select ${field.label}</option>
                                ${(field.options || []).map(opt => 
                                    `<option value="${Utils.sanitizeInput(opt)}" ${value === opt ? 'selected' : ''}>${Utils.sanitizeInput(opt)}</option>`
                                ).join('')}
                            </select>
                        `;
                    case 'date':
                        return `<input type="date" id="${id}" class="form-control" value="${value}" ${required}>`;
                    case 'number':
                        return `<input type="number" id="${id}" class="form-control" value="${value}" placeholder="Enter ${field.label.toLowerCase()}" ${required}>`;
                    case 'checkbox':
                        return `
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="${id}" ${value === 'true' || value === true ? 'checked' : ''} ${required}>
                                <label for="${id}" style="margin: 0;">${field.label}</label>
                            </div>
                        `;
                    default:
                        return `<input type="text" id="${id}" class="form-control" value="${Utils.sanitizeInput(value)}" placeholder="Enter ${field.label.toLowerCase()}" ${required}>`;
                }
            },

            canEditDocument() {
                return AppState.currentUser.permissions.includes('document_edit') || 
                       AppState.currentUser.permissions.includes('admin_access');
            },

            canDeleteDocument() {
                return AppState.currentUser.permissions.includes('document_delete') || 
                       AppState.currentUser.permissions.includes('admin_access');
            },

            canProcessOCR() {
                return AppState.currentUser.permissions.includes('document_ocr') || 
                       AppState.currentUser.permissions.includes('admin_access');
            },

            toggleEdit() {
                this.isEditing = true;
                this.updateEditButtons();
                this.renderDocumentInfo(AppState.currentDocument);
            },

            cancelEdit() {
                this.isEditing = false;
                this.updateEditButtons();
                this.renderDocumentInfo(AppState.currentDocument);
            },

            updateEditButtons() {
                const editBtn = document.getElementById('editDocumentBtn');
                const saveBtn = document.getElementById('saveDocumentBtn');
                const cancelBtn = document.getElementById('cancelEditBtn');
                
                if (editBtn) editBtn.style.display = this.isEditing ? 'none' : 'inline-flex';
                if (saveBtn) saveBtn.style.display = this.isEditing ? 'inline-flex' : 'none';
                if (cancelBtn) cancelBtn.style.display = this.isEditing ? 'inline-flex' : 'none';
            },

            async saveChanges() {
                try {
                    Utils.showToast('Saving changes...', 'info');
                    
                    // Collect updated field values
                    const updatedValues = {};
                    
                    AppState.selectedProject.index_fields.forEach(field => {
                        const input = document.getElementById(`input_${field.name}`);
                        if (input) {
                            if (input.type === 'checkbox') {
                                updatedValues[field.name] = input.checked;
                            } else {
                                updatedValues[field.name] = input.value.trim();
                            }
                        }
                    });
                    
                    // Save to backend
                    await API.put(`/documents/${AppState.currentDocument.id}`, {
                        index_values: updatedValues
                    });
                    
                    // Update local state
                    AppState.currentDocument.index_values = updatedValues;
                    
                    // Exit edit mode and refresh display
                    this.isEditing = false;
                    this.updateEditButtons();
                    this.renderDocumentInfo(AppState.currentDocument);
                    
                    Utils.showToast('Document updated successfully!', 'success');
                    
                    // Refresh search results if we have any
                    if (AppState.searchResults.length > 0) {
                        Search.perform();
                    }
                    
                } catch (error) {
                    Utils.showToast('Failed to save changes: ' + error.message, 'error');
                }
            },

            async delete(documentId, documentTitle, fromSearchResults = false) {
                if (!this.canDeleteDocument()) {
                    Utils.showToast('You do not have permission to delete documents', 'error');
                    return;
                }

                const confirmDelete = confirm(`Are you sure you want to delete the document "${documentTitle}"?\n\nThis will mark the document and all its pages as inactive. This action cannot be undone.`);
                if (!confirmDelete) {
                    return;
                }

                try {
                    Utils.showToast('Deleting document...', 'info');
                    
                    await API.delete(`/documents/${documentId}`);
                    
                    Utils.showToast('Document deleted successfully', 'success');
                    
                    // Close modal if we're viewing the deleted document
                    if (!fromSearchResults && AppState.currentDocument?.id === documentId) {
                        closeModal();
                    }
                    
                    // Refresh search results
                    if (AppState.searchResults.length > 0) {
                        Search.perform();
                    }
                    
                } catch (error) {
                    Utils.showToast('Failed to delete document: ' + error.message, 'error');
                }
            },

            displayPages(pages, container) {
                if (pages.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-light);">
                            <div style="font-size: 2rem; margin-bottom: 1rem;">üìÑ</div>
                            <p>No pages found for this document</p>
                        </div>
                    `;
                    return;
                }

                // Store current pages for reordering
                this.currentPages = [...pages];
                
                // Show reorder button if user can edit and there are multiple pages
                const reorderBtn = document.getElementById('reorderToggleBtn');
                if (reorderBtn && this.canEditDocument() && pages.length > 1) {
                    reorderBtn.style.display = 'inline-flex';
                }

                container.innerHTML = pages.map((page, index) => `
                    <div class="page-card ${this.isReorderMode ? 'reorder-mode' : ''}" 
                         data-page-id="${page.id}" 
                         data-original-index="${index}"
                         draggable="${this.isReorderMode ? 'true' : 'false'}"
                         onclick="${this.isReorderMode ? '' : `Documents.viewPage(${page.id})`}" 
                         title="${this.isReorderMode ? 'Drag to reorder' : 'Click to view full size'}">
                        <div class="page-thumbnail">
                            <img id="thumb-${page.id}" alt="Page ${page.page_number}" style="display: none;">
                            <div id="thumb-loading-${page.id}" style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-light);">
                                üìÑ
                            </div>
                        </div>
                        <div class="page-info">
                            <div class="page-number">Page ${page.page_number}</div>
                            <div class="page-source">
                                <span class="${page.source_type}-badge">${page.source_type.toUpperCase()}</span>
                                ${Utils.formatFileSize(page.file_size)}
                                ${page.has_ocr ? '<span class="ocr-status has-ocr">OCR</span>' : ''}
                            </div>
                        </div>
                        <div class="page-ocr-info ${this.showOCRInfo ? 'show' : ''}" id="page-ocr-${page.id}">
                            ${this.renderPageOCRInfo(page)}
                        </div>
                        <div class="page-index-info ${this.showIndexInfo ? 'show' : ''}" id="page-index-${page.id}">
                            ${this.renderPageIndexInfo()}
                        </div>
                    </div>
                `).join('');

                // Add drag and drop event listeners if in reorder mode
                if (this.isReorderMode) {
                    this.addDragAndDropListeners(container);
                }

                // Load thumbnails with authentication
                pages.forEach(page => {
                    this.loadThumbnail(page.id);
                });
            },

            renderPageOCRInfo(page) {
                const hasOCR = page.has_ocr;
                const wordCount = page.word_count || 0;
                const confidence = page.ocr_confidence || 0;
                
                if (!hasOCR) {
                    return `
                        <div class="page-ocr-status">
                            <span class="ocr-status no-ocr">No OCR</span>
                        </div>
                        <div class="page-ocr-actions">
                            <button class="btn btn-info btn-sm" onclick="event.stopPropagation(); OCR.processPage(${page.id})" title="Process OCR">
                                üîç Process OCR
                            </button>
                        </div>
                    `;
                }
                
                return `
                    <div class="page-ocr-status">
                        <span class="ocr-status has-ocr">OCR Ready</span>
                        <span style="font-size: 0.7rem; color: var(--text-light);">${wordCount} words</span>
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-light); margin: 0.25rem 0;">
                        Confidence: ${confidence.toFixed(1)}%
                    </div>
                    <div class="page-ocr-actions">
                        <button class="btn btn-outline btn-sm" onclick="event.stopPropagation(); Documents.viewPageOCR(${page.id})" title="View OCR Text">
                            üìÑ View Text
                        </button>
                        <button class="btn btn-warning btn-sm" onclick="event.stopPropagation(); OCR.processPage(${page.id})" title="Reprocess OCR">
                            üîÑ Reprocess
                        </button>
                    </div>
                `;
            },

            renderPageIndexInfo() {
                if (!AppState.currentDocument?.index_values || Object.keys(AppState.currentDocument.index_values).length === 0) {
                    return '<div style="text-align: center; color: var(--text-light); font-style: italic;">No index data</div>';
                }

                // Show only the most important fields (first 3) to keep cards compact
                const indexEntries = Object.entries(AppState.currentDocument.index_values).slice(0, 3);
                
                return indexEntries.map(([key, value]) => {
                    let displayValue = value;
                    
                    // Format display value based on field type
                    const field = AppState.selectedProject?.index_fields?.find(f => f.name === key);
                    if (field) {
                        if (field.type === 'number' && (key.includes('amount') || key.includes('value'))) {
                            displayValue = Utils.formatCurrency(parseFloat(value));
                        } else if (field.type === 'date') {
                            displayValue = Utils.formatDate(value);
                        } else if (field.type === 'checkbox') {
                            displayValue = value ? 'Yes' : 'No';
                        }
                    }
                    
                    // Truncate long values
                    if (typeof displayValue === 'string' && displayValue.length > 20) {
                        displayValue = displayValue.substring(0, 17) + '...';
                    }
                    
                    const fieldLabel = field ? field.label : key.replace(/_/g, ' ');
                    
                    return `
                        <div class="page-index-field">
                            <span class="page-index-label">${Utils.sanitizeInput(fieldLabel)}:</span>
                            <span class="page-index-value" title="${Utils.sanitizeInput(value)}">${Utils.sanitizeInput(displayValue)}</span>
                        </div>
                    `;
                }).join('');
            },

            toggleIndexInfo() {
                this.showIndexInfo = !this.showIndexInfo;
                
                const toggleBtn = document.getElementById('indexToggleBtn');
                const indexInfoElements = document.querySelectorAll('.page-index-info');
                
                if (this.showIndexInfo) {
                    toggleBtn.textContent = 'üìã Hide Index Info';
                    toggleBtn.classList.add('active');
                    indexInfoElements.forEach(el => el.classList.add('show'));
                    Utils.showToast('Index information shown', 'info');
                } else {
                    toggleBtn.textContent = 'üìã Show Index Info';
                    toggleBtn.classList.remove('active');
                    indexInfoElements.forEach(el => el.classList.remove('show'));
                    Utils.showToast('Index information hidden', 'info');
                }
            },

            toggleOCRInfo() {
                this.showOCRInfo = !this.showOCRInfo;
                
                const toggleBtn = document.getElementById('ocrToggleBtn');
                const ocrInfoElements = document.querySelectorAll('.page-ocr-info');
                
                if (this.showOCRInfo) {
                    toggleBtn.textContent = 'üîç Hide OCR Info';
                    toggleBtn.classList.add('active');
                    ocrInfoElements.forEach(el => el.classList.add('show'));
                    Utils.showToast('OCR information shown', 'info');
                } else {
                    toggleBtn.textContent = 'üîç Show OCR Info';
                    toggleBtn.classList.remove('active');
                    ocrInfoElements.forEach(el => el.classList.remove('show'));
                    Utils.showToast('OCR information hidden', 'info');
                }
            },

            toggleDocumentInfo() {
                this.showDocumentInfo = !this.showDocumentInfo;
                
                const toggleBtn = document.getElementById('infoToggleBtn');
                const documentInfo = document.getElementById('documentInfo');
                
                if (this.showDocumentInfo) {
                    toggleBtn.textContent = 'üìÑ Hide Document Info';
                    toggleBtn.classList.add('active');
                    documentInfo.classList.remove('hidden-info');
                    Utils.showToast('Document information shown', 'info');
                } else {
                    toggleBtn.textContent = 'üìÑ Show Document Info';
                    toggleBtn.classList.remove('active');
                    documentInfo.classList.add('hidden-info');
                    Utils.showToast('Document information hidden - showing pages only', 'info');
                }
            },

            toggleOCRControls() {
                const ocrControls = document.getElementById('ocrControls');
                const toggleBtn = document.getElementById('toggleOCRControlsBtn');
                
                if (ocrControls.style.display === 'none') {
                    ocrControls.style.display = 'block';
                    toggleBtn.textContent = 'üîß Hide OCR Controls';
                    toggleBtn.classList.add('active');
                } else {
                    ocrControls.style.display = 'none';
                    toggleBtn.textContent = 'üîß OCR Controls';
                    toggleBtn.classList.remove('active');
                }
            },

            initializeOCRControls() {
                const ocrControls = document.getElementById('ocrControls');
                if (this.canProcessOCR()) {
                    ocrControls.style.display = 'none'; // Hidden by default
                } else {
                    ocrControls.style.display = 'none';
                }
            },

            updateOCRStats(pages) {
                const pagesWithOCR = pages.filter(page => page.has_ocr).length;
                const totalWords = pages.reduce((sum, page) => sum + (page.word_count || 0), 0);
                const avgConfidence = pages.filter(page => page.ocr_confidence).length > 0 
                    ? pages.filter(page => page.ocr_confidence).reduce((sum, page) => sum + page.ocr_confidence, 0) / pages.filter(page => page.ocr_confidence).length
                    : 0;

                const statsElement = document.getElementById('ocrStats');
                const processedElement = document.getElementById('ocrPagesProcessed');
                const wordsElement = document.getElementById('ocrTotalWords');
                const confidenceElement = document.getElementById('ocrAvgConfidence');

                if (pagesWithOCR > 0) {
                    statsElement.style.display = 'block';
                    if (processedElement) processedElement.textContent = pagesWithOCR;
                    if (wordsElement) wordsElement.textContent = totalWords.toLocaleString();
                    if (confidenceElement) confidenceElement.textContent = avgConfidence.toFixed(1) + '%';
                } else {
                    statsElement.style.display = 'none';
                }
            },

            async viewPageOCR(pageId) {
                try {
                    const ocrData = await OCR.getPageOCRText(pageId);
                    if (ocrData && ocrData.ocr_text) {
                        const modal = confirm(`OCR Text for Page ${ocrData.page_number}:\n\nConfidence: ${ocrData.ocr_confidence}%\nWord Count: ${ocrData.word_count}\n\n${ocrData.ocr_text.substring(0, 500)}${ocrData.ocr_text.length > 500 ? '...' : ''}\n\nClick OK to view full text in new window.`);
                        if (modal) {
                            const newWindow = window.open('', '_blank');
                            newWindow.document.write(`
                                <html>
                                <head>
                                    <title>OCR Text - Page ${ocrData.page_number}</title>
                                    <style>
                                        body { font-family: Arial, sans-serif; margin: 2rem; line-height: 1.6; }
                                        .header { background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 2rem; }
                                        .stats { display: flex; gap: 2rem; margin-bottom: 1rem; }
                                        .stat { text-align: center; }
                                        .stat-value { font-size: 1.5rem; font-weight: bold; color: #667eea; }
                                        .stat-label { font-size: 0.9rem; color: #666; }
                                        .text-content { background: white; padding: 2rem; border: 1px solid #ddd; border-radius: 8px; white-space: pre-wrap; }
                                    </style>
                                </head>
                                <body>
                                    <div class="header">
                                        <h1>OCR Text Extraction</h1>
                                        <h2>Document: ${AppState.currentDocument.title}</h2>
                                        <h3>Page ${ocrData.page_number}</h3>
                                        <div class="stats">
                                            <div class="stat">
                                                <div class="stat-value">${ocrData.ocr_confidence}%</div>
                                                <div class="stat-label">Confidence</div>
                                            </div>
                                            <div class="stat">
                                                <div class="stat-value">${ocrData.word_count}</div>
                                                <div class="stat-label">Words</div>
                                            </div>
                                            <div class="stat">
                                                <div class="stat-value">${ocrData.ocr_language.toUpperCase()}</div>
                                                <div class="stat-label">Language</div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="text-content">${ocrData.ocr_text}</div>
                                </body>
                                </html>
                            `);
                        }
                    } else {
                        Utils.showToast('No OCR text available for this page', 'warning');
                    }
                } catch (error) {
                    Utils.showToast('Failed to load OCR text: ' + error.message, 'error');
                }
            },

            async loadThumbnail(pageId) {
                try {
                    const response = await fetch(`${AppState.apiBase}/pages/${pageId}/thumbnail`, {
                        headers: {
                            'Authorization': `Bearer ${AppState.token}`
                        }
                    });

                    if (response.ok) {
                        const blob = await response.blob();
                        const imageUrl = URL.createObjectURL(blob);
                        
                        const imgElement = document.getElementById(`thumb-${pageId}`);
                        const loadingElement = document.getElementById(`thumb-loading-${pageId}`);
                        
                        if (imgElement && loadingElement) {
                            imgElement.src = imageUrl;
                            imgElement.style.display = 'block';
                            imgElement.style.width = '100%';
                            imgElement.style.height = '100%';
                            imgElement.style.objectFit = 'cover';
                            loadingElement.style.display = 'none';
                            
                            imgElement.onload = () => {
                                imgElement.dataset.blobUrl = imageUrl;
                            };
                        }
                    } else {
                        console.warn(`Failed to load thumbnail for page ${pageId}: ${response.status}`);
                    }
                } catch (error) {
                    console.error(`Error loading thumbnail for page ${pageId}:`, error);
                }
            },

            async viewPage(pageId) {
                try {
                    Utils.showToast('Loading page...', 'info');
                    
                    // Fetch the page content with authentication
                    const response = await fetch(`${AppState.apiBase}/pages/${pageId}/content`, {
                        headers: {
                            'Authorization': `Bearer ${AppState.token}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to load page: ${response.status} ${response.statusText}`);
                    }

                    // Get the content type to determine how to handle the response
                    const contentType = response.headers.get('content-type');
                    const blob = await response.blob();
                    
                    // Create a blob URL and open it in a new window
                    const blobUrl = URL.createObjectURL(blob);
                    const newWindow = window.open(blobUrl, '_blank');
                    
                    // Clean up the blob URL after a delay to allow the window to load
                    setTimeout(() => {
                        URL.revokeObjectURL(blobUrl);
                    }, 5000);
                    
                    if (!newWindow) {
                        Utils.showToast('Please allow popups to view page content', 'warning');
                    }
                    
                } catch (error) {
                    console.error('Error loading page:', error);
                    Utils.showToast('Failed to load page: ' + error.message, 'error');
                }
            },

            // Page Reordering Methods
            toggleReorderMode() {
                this.isReorderMode = !this.isReorderMode;
                
                const reorderBtn = document.getElementById('reorderToggleBtn');
                const saveBtn = document.getElementById('saveReorderBtn');
                const cancelBtn = document.getElementById('cancelReorderBtn');
                
                if (this.isReorderMode) {
                    // Store original page order
                    this.originalPageOrder = [...this.currentPages];
                    
                    // Update UI
                    reorderBtn.style.display = 'none';
                    saveBtn.style.display = 'inline-flex';
                    cancelBtn.style.display = 'inline-flex';
                    
                    // Refresh display with drag and drop enabled
                    const container = document.getElementById('pageGrid');
                    this.displayPages(this.currentPages, container);
                    
                    Utils.showToast('Drag and drop pages to reorder. Click Save Order when done.', 'info');
                } else {
                    this.exitReorderMode();
                }
            },

            exitReorderMode() {
                this.isReorderMode = false;
                
                const reorderBtn = document.getElementById('reorderToggleBtn');
                const saveBtn = document.getElementById('saveReorderBtn');
                const cancelBtn = document.getElementById('cancelReorderBtn');
                
                reorderBtn.style.display = 'inline-flex';
                saveBtn.style.display = 'none';
                cancelBtn.style.display = 'none';
                
                // Refresh display
                const container = document.getElementById('pageGrid');
                this.displayPages(this.currentPages, container);
            },

            cancelReorder() {
                // Restore original order
                this.currentPages = [...this.originalPageOrder];
                this.exitReorderMode();
                Utils.showToast('Page reordering cancelled', 'info');
            },

            // Add Pages Functionality
            initializeAddPagesDropZone() {
                const dropZone = document.getElementById('addPagesDropZone');
                const fileInput = document.getElementById('addPagesFileInput');
                
                if (!dropZone || !fileInput) return;
                
                // File input change handler
                fileInput.addEventListener('change', (e) => {
                    this.handleAddPagesFiles(e.target.files);
                });
                
                // Drag and drop handlers for the drop zone
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dropZone.classList.add('drag-over');
                });
                
                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Only remove drag-over if we're leaving the drop zone entirely
                    if (!dropZone.contains(e.relatedTarget)) {
                        dropZone.classList.remove('drag-over');
                    }
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dropZone.classList.remove('drag-over');
                    this.handleAddPagesFiles(e.dataTransfer.files);
                });
            },

            showAddPagesDropZone() {
                const dropZone = document.getElementById('addPagesDropZone');
                if (dropZone) {
                    dropZone.classList.remove('hidden');
                    Utils.showToast('Drop files here or click Browse Files to add new pages with optional OCR processing', 'info');
                }
            },

            hideAddPagesDropZone() {
                const dropZone = document.getElementById('addPagesDropZone');
                const fileInput = document.getElementById('addPagesFileInput');
                const uploadProgress = document.getElementById('uploadProgress');
                
                if (dropZone) {
                    dropZone.classList.add('hidden');
                    dropZone.classList.remove('drag-over');
                }
                
                if (fileInput) {
                    fileInput.value = '';
                }
                
                if (uploadProgress) {
                    uploadProgress.classList.add('hidden');
                }
            },

            async handleAddPagesFiles(files) {
                const validFiles = Array.from(files).filter(file => {
                    const validTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/tiff'];
                    return validTypes.includes(file.type) || file.name.toLowerCase().match(/\.(pdf|jpg|jpeg|png|tiff|tif)$/);
                });

                if (validFiles.length === 0) {
                    Utils.showToast('No valid files selected. Please choose PDF or image files.', 'warning');
                    return;
                }

                if (validFiles.length !== files.length) {
                    Utils.showToast(`${files.length - validFiles.length} files were skipped due to invalid format`, 'warning');
                }

                await this.uploadNewPages(validFiles);
            },

            async uploadNewPages(files) {
                const uploadProgress = document.getElementById('uploadProgress');
                const uploadStatus = document.getElementById('uploadStatus');
                const uploadPercent = document.getElementById('uploadPercent');
                const progressFill = document.getElementById('progressFill');
                const performOCR = document.getElementById('addPagesOCR').checked;

                try {
                    uploadProgress.classList.remove('hidden');
                    uploadStatus.textContent = 'Preparing upload...';
                    uploadPercent.textContent = '0%';
                    progressFill.style.width = '0%';

                    let totalFiles = files.length;
                    let completedFiles = 0;
                    let totalPages = 0;

                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        
                        uploadStatus.textContent = `Uploading ${file.name}${performOCR ? ' with OCR...' : '...'}`;
                        const progress = Math.round((i / totalFiles) * 100);
                        uploadPercent.textContent = `${progress}%`;
                        progressFill.style.width = `${progress}%`;

                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('perform_ocr', performOCR ? 'true' : 'false');

                        const uploadResult = await API.uploadFile(`/documents/${AppState.currentDocument.id}/pages`, formData);
                        
                        completedFiles++;
                        totalPages += uploadResult.total_pages || 1;

                        if (file.type === 'application/pdf' && uploadResult.file_type === 'pdf') {
                            const ocrMsg = performOCR && uploadResult.ocr_words_found ? ` (${uploadResult.ocr_words_found} words extracted)` : '';
                            Utils.showToast(`PDF "${file.name}" split into ${uploadResult.total_pages} pages${ocrMsg}`, 'success');
                        } else {
                            const ocrMsg = performOCR && uploadResult.ocr_words_found ? ` (${uploadResult.ocr_words_found} words extracted)` : '';
                            Utils.showToast(`Image "${file.name}" added as 1 page${ocrMsg}`, 'success');
                        }
                    }

                    // Final progress update
                    uploadStatus.textContent = `Upload complete${performOCR ? ' with OCR processing' : ''}!`;
                    uploadPercent.textContent = '100%';
                    progressFill.style.width = '100%';

                    const ocrMsg = performOCR ? ' with OCR text extraction' : '';
                    Utils.showToast(`Successfully added ${totalPages} new pages to the document${ocrMsg}!`, 'success');

                    // Refresh the page display
                    setTimeout(async () => {
                        await this.refreshPageDisplay();
                        this.hideAddPagesDropZone();
                    }, 1500);

                } catch (error) {
                    console.error('Error uploading pages:', error);
                    Utils.showToast('Failed to upload pages: ' + error.message, 'error');
                    uploadStatus.textContent = 'Upload failed';
                    uploadPercent.textContent = 'Error';
                    progressFill.style.width = '0%';
                }
            },

            async refreshPageDisplay() {
                try {
                    const pages = await API.get(`/documents/${AppState.currentDocument.id}/pages`);
                    const pageGrid = document.getElementById('pageGrid');
                    
                    // Update document page count
                    AppState.currentDocument.page_count = pages.length;
                    
                    // Refresh the document info to show updated page count and OCR status
                    this.renderDocumentInfo(AppState.currentDocument);
                    this.updateOCRStats(pages);
                    
                    // Refresh the page display
                    this.displayPages(pages, pageGrid);
                    
                    Utils.showToast('Page display refreshed', 'success');
                    
                } catch (error) {
                    console.error('Error refreshing page display:', error);
                    Utils.showToast('Failed to refresh page display: ' + error.message, 'error');
                }
            },

            async savePageOrder() {
                try {
                    Utils.showToast('Saving new page order...', 'info');
                    
                    // Create page order array for API
                    const pageOrder = this.currentPages.map((page, index) => ({
                        page_id: page.id,
                        new_page_number: index + 1
                    }));
                    
                    // Send to API
                    const response = await API.put(`/documents/${AppState.currentDocument.id}/pages/reorder`, {
                        page_order: pageOrder
                    });
                    
                    if (response.success) {
                        // Update page numbers in current pages
                        this.currentPages.forEach((page, index) => {
                            page.page_number = index + 1;
                            page.page_order = index + 1;
                        });
                        
                        this.exitReorderMode();
                        Utils.showToast('Page order saved successfully!', 'success');
                    } else {
                        throw new Error(response.error || 'Failed to save page order');
                    }
                    
                } catch (error) {
                    console.error('Error saving page order:', error);
                    Utils.showToast('Failed to save page order: ' + error.message, 'error');
                }
            },

            addDragAndDropListeners(container) {
                const pageCards = container.querySelectorAll('.page-card');
                
                pageCards.forEach(card => {
                    // Drag start
                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/html', card.outerHTML);
                        e.dataTransfer.setData('text/plain', card.dataset.pageId);
                        card.classList.add('dragging');
                        
                        // Store the dragged element
                        this.draggedElement = card;
                    });

                    // Drag end
                    card.addEventListener('dragend', (e) => {
                        card.classList.remove('dragging');
                        this.draggedElement = null;
                        
                        // Remove drag-over class from all cards
                        pageCards.forEach(c => c.classList.remove('drag-over'));
                    });

                    // Drag over
                    card.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        
                        if (card !== this.draggedElement) {
                            card.classList.add('drag-over');
                        }
                    });

                    // Drag leave
                    card.addEventListener('dragleave', (e) => {
                        card.classList.remove('drag-over');
                    });

                    // Drop
                    card.addEventListener('drop', (e) => {
                        e.preventDefault();
                        card.classList.remove('drag-over');
                        
                        if (card !== this.draggedElement) {
                            this.reorderPages(this.draggedElement, card);
                        }
                    });
                });
            },

            reorderPages(draggedCard, targetCard) {
                const draggedPageId = parseInt(draggedCard.dataset.pageId);
                const targetPageId = parseInt(targetCard.dataset.pageId);
                
                // Find pages in current array
                const draggedIndex = this.currentPages.findIndex(p => p.id === draggedPageId);
                const targetIndex = this.currentPages.findIndex(p => p.id === targetPageId);
                
                if (draggedIndex === -1 || targetIndex === -1) {
                    console.error('Could not find pages for reordering');
                    return;
                }
                
                // Move page in array
                const [draggedPage] = this.currentPages.splice(draggedIndex, 1);
                this.currentPages.splice(targetIndex, 0, draggedPage);
                
                // Refresh display
                const container = document.getElementById('pageGrid');
                this.displayPages(this.currentPages, container);
                
                Utils.showToast('Pages reordered. Click "Save Order" to persist changes.', 'warning');
            },

            async create(documentData, files, performOCR = false) {
                try {
                    console.log('üìù Creating document record...');
                    console.log('üìù Document data:', documentData);
                    
                    const createdDocument = await API.post(`/projects/${AppState.selectedProject.id}/documents`, documentData);
                    console.log('‚úÖ Document created with ID:', createdDocument.id);
                    
                    if (files && files.length > 0) {
                        console.log(`üì§ Uploading ${files.length} files to document ${createdDocument.id} (OCR: ${performOCR})...`);
                        
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            console.log(`üì§ Uploading file ${i + 1}/${files.length}: ${file.name} to document ${createdDocument.id}`);
                            
                            const formData = new FormData();
                            formData.append('file', file);
                            formData.append('perform_ocr', performOCR ? 'true' : 'false');
                            
                            const uploadResult = await API.uploadFile(`/documents/${createdDocument.id}/pages`, formData);
                            console.log(`‚úÖ Upload result for ${file.name}:`, uploadResult);
                            
                            if (file.type === 'application/pdf' && uploadResult.file_type === 'pdf') {
                                const ocrMsg = performOCR && uploadResult.ocr_words_found ? ` (${uploadResult.ocr_words_found} words extracted)` : '';
                                Utils.showToast(`PDF "${file.name}" split into ${uploadResult.total_pages} pages${ocrMsg}`, 'success');
                                console.log(`üìÑ PDF "${file.name}" split into ${uploadResult.total_pages} pages for document ${createdDocument.id}`);
                            } else {
                                const ocrMsg = performOCR && uploadResult.ocr_words_found ? ` (${uploadResult.ocr_words_found} words extracted)` : '';
                                console.log(`üñºÔ∏è Image "${file.name}" added as 1 page to document ${createdDocument.id}${ocrMsg}`);
                            }
                        }
                        
                        console.log(`‚úÖ All ${files.length} files uploaded successfully to document ${createdDocument.id}`);
                    } else {
                        console.log('‚ÑπÔ∏è No files to upload');
                    }
                    
                    return createdDocument;
                    
                } catch (error) {
                    console.error('‚ùå Document creation error:', error);
                    throw new Error('Failed to create document: ' + error.message);
                }
            }
        };

        // Enhanced Document Upload Module with OCR Support
        const DocumentUpload = {
            initializeUploadArea() {
                const uploadArea = document.getElementById('fileUploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('drag-over');
                });

                uploadArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('drag-over');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('drag-over');
                    this.handleFiles(e.dataTransfer.files);
                });
            },

            handleFiles(files) {
                const validFiles = Array.from(files).filter(file => {
                    const validTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/tiff'];
                    return validTypes.includes(file.type) || file.name.toLowerCase().match(/\.(pdf|jpg|jpeg|png|tiff|tif)$/);
                });

                if (validFiles.length !== files.length) {
                    Utils.showToast('Some files were skipped due to invalid format', 'warning');
                }

                // If this is the first file being added, set the document title to the filename
                if (AppState.uploadFiles.length === 0 && validFiles.length > 0) {
                    const firstFile = validFiles[0];
                    // Remove file extension from filename for cleaner title
                    const titleWithoutExtension = firstFile.name.replace(/\.[^/.]+$/, "");
                    const titleInput = document.getElementById('docTitle');
                    if (titleInput) {
                        titleInput.value = titleWithoutExtension;
                        Utils.showToast(`Document title set to: "${titleWithoutExtension}"`, 'success');
                    }
                }

                AppState.uploadFiles = [...AppState.uploadFiles, ...validFiles];
                this.updateFileList();
            },

            updateFileList() {
                const fileList = document.getElementById('fileList');
                
                if (AppState.uploadFiles.length === 0) {
                    fileList.innerHTML = '';
                    return;
                }

                fileList.innerHTML = AppState.uploadFiles.map((file, index) => `
                    <div class="file-item">
                        <div class="file-info">
                            ${Utils.getFileTypeIcon(file.name)}
                            <span>${Utils.sanitizeInput(file.name)}</span>
                            <span class="file-size">(${Utils.formatFileSize(file.size)})</span>
                            ${file.type === 'application/pdf' ? '<span class="pdf-badge">PDF</span>' : ''}
                        </div>
                        <button type="button" class="file-remove" onclick="DocumentUpload.removeFile(${index})" title="Remove file">
                            √ó
                        </button>
                    </div>
                `).join('');
            },

            removeFile(index) {
                AppState.uploadFiles.splice(index, 1);
                
                // If all files are removed, clear the document title
                if (AppState.uploadFiles.length === 0) {
                    const titleInput = document.getElementById('docTitle');
                    if (titleInput) {
                        titleInput.value = '';
                        titleInput.placeholder = 'Title will be set automatically from filename';
                    }
                }
                
                this.updateFileList();
            },

            setupDynamicFields() {
                const container = document.getElementById('dynamicIndexFields');
                
                if (!AppState.selectedProject || !AppState.selectedProject.index_fields) {
                    container.innerHTML = '<p style="color: var(--text-light);">No index fields configured for this project.</p>';
                    return;
                }

                const fieldsHtml = AppState.selectedProject.index_fields.map(field => {
                    return `
                        <div class="form-group">
                            <label for="index_${field.name}">
                                ${Utils.sanitizeInput(field.label)}
                                ${field.required ? ' *' : ''}
                            </label>
                            ${this.createIndexInput(field)}
                        </div>
                    `;
                }).join('');

                container.innerHTML = `<div class="form-row">${fieldsHtml}</div>`;
            },

            createIndexInput(field) {
                const id = `index_${field.name}`;
                const required = field.required ? 'required' : '';
                
                switch (field.type) {
                    case 'dropdown':
                        return `
                            <select id="${id}" class="form-control" ${required}>
                                <option value="">Select ${field.label}</option>
                                ${(field.options || []).map(opt => 
                                    `<option value="${Utils.sanitizeInput(opt)}">${Utils.sanitizeInput(opt)}</option>`
                                ).join('')}
                            </select>
                        `;
                    case 'date':
                        return `<input type="date" id="${id}" class="form-control" ${required}>`;
                    case 'number':
                        return `<input type="number" id="${id}" class="form-control" placeholder="Enter ${field.label.toLowerCase()}" ${required}>`;
                    case 'checkbox':
                        return `
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="${id}" ${required}>
                                <label for="${id}" style="margin: 0;">${field.label}</label>
                            </div>
                        `;
                    default:
                        return `<input type="text" id="${id}" class="form-control" placeholder="Enter ${field.label.toLowerCase()}" ${required}>`;
                }
            },

            getIndexValues() {
                const values = {};
                
                if (!AppState.selectedProject?.index_fields) return values;

                AppState.selectedProject.index_fields.forEach(field => {
                    const input = document.getElementById(`index_${field.name}`);
                    if (input) {
                        if (input.type === 'checkbox') {
                            values[field.name] = input.checked;
                        } else if (input.value.trim()) {
                            values[field.name] = input.value.trim();
                        }
                    }
                });

                return values;
            },

            resetForm() {
                document.getElementById('addDocumentForm').reset();
                
                // Reset title field placeholder
                const titleInput = document.getElementById('docTitle');
                if (titleInput) {
                    titleInput.placeholder = 'Title will be set automatically from filename';
                }

                // Reset OCR checkbox to checked
                const ocrCheckbox = document.getElementById('uploadOCR');
                if (ocrCheckbox) {
                    ocrCheckbox.checked = true;
                }
                
                AppState.uploadFiles = [];
                this.updateFileList();
            }
        };

        // Global Functions
        window.logout = () => Auth.logout();
        window.performSearch = () => Search.perform();
        window.clearSearch = () => Search.clear();
        window.refreshProjects = () => Projects.load();
        window.closeModal = () => {
            const thumbnails = document.querySelectorAll('#pageGrid img[data-blob-url]');
            thumbnails.forEach(img => {
                if (img.dataset.blobUrl) {
                    URL.revokeObjectURL(img.dataset.blobUrl);
                }
            });
            
            // Hide add pages drop zone when closing modal
            Documents.hideAddPagesDropZone();
            
            document.getElementById('documentModal').classList.remove('active');
            document.body.style.overflow = '';
        };

        window.showAddDocumentModal = () => {
            if (!AppState.selectedProject) {
                Utils.showToast('Please select a project first', 'warning');
                return;
            }

            if (!AppState.currentUser.permissions.includes('document_create') && !AppState.currentUser.permissions.includes('admin_access')) {
                Utils.showToast('You do not have permission to create documents', 'error');
                return;
            }

            DocumentUpload.setupDynamicFields();
            DocumentUpload.resetForm();
            
            const modal = document.getElementById('addDocumentModal');
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        };

        window.closeAddDocumentModal = () => {
            const modal = document.getElementById('addDocumentModal');
            modal.classList.remove('active');
            document.body.style.overflow = '';
            DocumentUpload.resetForm();
        };

        // Search tab switching
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('search-tab')) {
                Search.switchTab(e.target.dataset.tab);
            }
        });

        // View management
        window.changeView = (viewType) => {
            AppState.currentView = viewType;
            
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === viewType);
            });
            
            const grid = document.getElementById('documentGrid');
            grid.className = `document-grid ${viewType}-view`;
            
            if (AppState.searchResults.length > 0) {
                Search.displayResults(AppState.searchResults);
            }
            
            Utils.showToast(`Switched to ${viewType} view`, 'info');
        };

        window.sortResults = () => {
            const sortBy = document.getElementById('sortOptions').value;
            
            AppState.searchResults.sort((a, b) => {
                switch (sortBy) {
                    case 'date_desc':
                        return new Date(b.created_at) - new Date(a.created_at);
                    case 'date_asc':
                        return new Date(a.created_at) - new Date(b.created_at);
                    case 'title_asc':
                        return a.title.localeCompare(b.title);
                    case 'title_desc':
                        return b.title.localeCompare(a.title);
                    case 'relevance':
                        // For full-text search results, sort by highest number of matches
                        if (a.search_matches && b.search_matches) {
                            return b.search_matches.length - a.search_matches.length;
                        }
                        return 0;
                    default:
                        return 0;
                }
            });
            
            Search.displayResults(AppState.searchResults);
            Utils.showToast('Results sorted', 'info');
        };

        window.quickDownload = (docId) => {
            Utils.showToast('Download feature coming soon...', 'info');
        };

        window.toggleQuickFavorite = (docId) => {
            Utils.showToast('Favorites feature coming soon...', 'info');
        };

        window.showRecentDocuments = () => {
            Utils.showToast('Recent documents feature coming soon...', 'info');
        };

        window.showFavoriteDocuments = () => {
            Utils.showToast('Favorites feature coming soon...', 'info');
        };

        window.exportResults = () => {
            if (AppState.searchResults.length === 0) {
                Utils.showToast('No results to export', 'warning');
                return;
            }
            Utils.showToast('Export feature coming soon...', 'info');
        };

        // Login form handler
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            await Auth.login(username, password);
        });

        // Add document form handler with OCR support
        document.getElementById('addDocumentForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (AppState.isSubmitting) {
                console.log('‚ö†Ô∏è Form already submitting, ignoring duplicate submission');
                Utils.showToast('Please wait, already processing...', 'warning');
                return;
            }
            
            try {
                AppState.isSubmitting = true;
                Utils.setLoading('submitDocumentBtn', true);
                
                const performOCR = document.getElementById('uploadOCR').checked;
                
                console.log('üöÄ Starting document creation...');
                console.log('üìÅ Files to upload:', AppState.uploadFiles.length);
                console.log('üîç OCR processing:', performOCR);
                AppState.uploadFiles.forEach((file, i) => {
                    console.log(`  File ${i + 1}: ${file.name} (${file.type})`);
                });
                
                const title = document.getElementById('docTitle').value.trim();
                const index_values = DocumentUpload.getIndexValues();
                
                if (!title) {
                    Utils.showToast('Document title is required', 'error');
                    return;
                }
                
                if (AppState.uploadFiles.length === 0) {
                    const confirmNoFiles = confirm('No files selected. Create document without files?');
                    if (!confirmNoFiles) {
                        return;
                    }
                }
                
                const documentData = {
                    title,
                    index_values
                };
                
                console.log('üìù Creating document with data:', documentData);
                const createdDocument = await Documents.create(documentData, AppState.uploadFiles, performOCR);
                console.log('‚úÖ Document created successfully:', createdDocument);
                
                const ocrMsg = performOCR ? ' with OCR text extraction' : '';
                Utils.showToast(`Document created successfully${ocrMsg}!`, 'success');
                closeAddDocumentModal();
                
                if (AppState.searchResults.length > 0) {
                    performSearch();
                }
                
            } catch (error) {
                console.error('‚ùå Document creation failed:', error);
                Utils.showToast(error.message, 'error');
            } finally {
                AppState.isSubmitting = false;
                Utils.setLoading('submitDocumentBtn', false);
            }
        });

        // Modal close on backdrop click
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                if (e.target.id === 'documentModal') {
                    closeModal();
                } else if (e.target.id === 'addDocumentModal') {
                    closeAddDocumentModal();
                }
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
                closeAddDocumentModal();
            }
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                const activeTab = Search.currentTab;
                if (activeTab === 'fulltext') {
                    document.getElementById('fulltextQuery')?.focus();
                } else {
                    document.getElementById('searchFields')?.querySelector('.form-control')?.focus();
                }
            }
        });

        // Event Handlers
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üìÑ Enhanced Document Search & Viewer Interface with OCR Loading...');
            console.log('üîç OCR text extraction enabled');
            console.log('üìù Full-text search enabled');
            console.log('üîÑ PDF page splitting enabled');
            console.log('üìù Auto-title from filename enabled');
            console.log('‚úèÔ∏è Document field editing enabled');
            console.log('üóëÔ∏è Document soft delete enabled');
            console.log('üìã Page index info toggle enabled');
            console.log('üìÑ Document info toggle enabled');
            console.log('üîÑ Page drag & drop reordering enabled');
            console.log('üì§ Add pages to existing documents enabled');
            console.log('üîê Fixed authentication for page viewing');
            
            DocumentUpload.initializeUploadArea();
            
            const isAuthenticated = await Auth.validateToken();
            
            if (isAuthenticated) {
                Auth.showMainApp();
            } else {
                Auth.showLogin();
            }
        });

        console.log('‚úÖ Enhanced Document Search & Viewer Interface with OCR Ready');
        console.log('üîó Connected to API at:', AppState.apiBase);
        console.log('üîç OCR text extraction ready');
        console.log('üìù Full-text search ready');
        console.log('üìë PDF page splitting ready');
        console.log('üìù Auto-title from filename ready');
        console.log('‚úèÔ∏è Document editing ready');
        console.log('üóëÔ∏è Soft delete ready');
        console.log('üìã Page index info toggle ready');
        console.log('üìÑ Document info toggle ready');
        console.log('üîÑ Page drag & drop reordering ready');
        console.log('üì§ Add pages to existing documents ready');
        console.log('üîê Authentication fix for page viewing ready');
    </script>
</body>
</html>